/*
    source: https://vjudge.net/problem/UVA-11300
    题意： n个人站一个圈，每个人有一个val, 所有val加起来等于n*m
        每个人可以转移val给两侧的人（数量随你，只要还有val就能转）
        问 要是每个人最后的val都为m，转移的最少量
    思路：
        ************************************************************
        1. 遇到环形问题，可以先随便定一个方向，比如说只能逆时针转，但是转移的量可正可负，这样即吻合题意，有便于数学处理（设置为x之类的）
        ********************************************************
        2. 遇到环形问题，环形中的每一个元素相当于只被其左右两侧的影响，这样可以只考虑局部，这也是很多问题的思路
        ************************************************************
        3. 接下来，就是math
        设初始值为ai，xi为第i个点向第i-1个点转移的量（若i==1，则i-1为n）
        有
            ai - xi + x(i+1) == m
        这是一个n元方程组，但实际上有 Sum{ai} = n*m 这个恒等式与前n-1个方程可得第n项:
            n*m - an - x1 + xn == n*m - m
                an - xn + x1 = m
        所以解方程的思维失败（实际上也不可能给你解出来，显然有无穷个解）
        ************************************************************************************************
        怎么求解一个多元式的最小值？除了一眼看出来不等式，就是转化成单变量的函数，这是高中数学的做法
        ***********************************************************************************************
        可以先尝试一下：
            x2 = x1 + m - a1
            x3 = x2 + m - a2 = x1 + 2*m - (a1+a2)
            x4 = x3 + m - a3 = x1 + 3*m - (a1+a2+a3)

            xi = x1 + (i-1)*m - Sum{a1,a2,...,ai-1}
        
        把常数项用符号代替便于观察
        def (i-1)*m - Sum{a1,a2,...,ai-1} == Ai-1

            xi = x1 + Ai-1

        最后答案要求 min{ abs(x1) + abs(x1+A1) + abs(x1+A2) + abs(x1+A3) + ... + abs(x1+An-1)}

        ************************************************************
        对于这种一串绝对值的和，且绝对值中有相同的数x1，想到转化为数轴上的距离
        ************************************************************

        def Bi = -Ai
        min{ abs(x1-0) + abs(x1-B1) + ... + abs(x1-Bn-1)}
        等价于求一个x1，使其到0，B1，B2，B3, ... Bn-1 的距离最小
        即求中位数
        sort取n/2即可（从0开始）
*/

#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn = 1e6+6;
int n;
ll sum[maxn],c[maxn];
ll m,x1;
signed main()
{
    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
    while(cin>>n)
    {
        for(int i=1;i<=n;i++)
        {
            cin>>sum[i];
            sum[i] += sum[i-1];
        }
        m = sum[n]/n;
        c[0] = 0;
        for(int i=1;i<n;i++)
        {
            c[i] = sum[i] - i*m;
        }
        sort(c,c+n);
        x1 = c[n/2];
        ll ans = 0;
        for(int i=0;i<n;i++)
        {
            ans+=abs(x1-c[i]);
        }
        cout<<ans<<endl;
    }
}